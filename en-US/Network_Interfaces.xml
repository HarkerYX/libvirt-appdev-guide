<?xml version='1.0'?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
	  ]>

<chapter id="Application_Development_Guide-Network_Interfaces">
  <title>Network Interfaces</title>
  <para>
    This section covers the management of physical network interfaces
    using the libvirt API.
  </para>

  <section id="Application_Development_Guide-Network_Interfaces-Overview">
    <title>Overview</title>
    <para>
      The configuration of network interfaces on physical hosts can be
      examined and modified with functions in the virInterface API. This is
      useful for setting up the host to share one physical interface bewteen
      multiple guest domains you want connected directly to the network
      (briefly - enslave a physical interface to the bridge, then create a
      tap device for each VM you want to share the interface), as well as
      for general host network interface management. In addition to physical
      hardware, this API can also be used to configure bridges, bonded
      interfaces, and vlan interfaces.
    </para>
    <para>
      The virInterface API is *not* used to configure virtual networks (used
      to conceal the guest domain's interface behind a NAT); virtual networks are
      instead configured using the virNetwork API described in chapter 6.
    </para>
    <para>
      Each host interface is represented in the API by a virInterfacePtr - a
      pointer to an "interface object" - and each of these has a single
      unique identifier:
    </para>
    <para>
      name: a string unique among all interfaces (active or inactive) on a
      host. This is the same string used by the operating system to identify
      the interface (eg: "eth0" or "br1").
    </para>
    <para>
      Each interface object also has a second, non-unique index that can be
      duplicated in other interfaces on the same host:
    </para>
    <para>
      mac: an ASCII string representation of the MAC address of this
      interface. Since multiple interfaces can share the same MAC address
      (for example, in the case of VLANs), this is *not* a unique
      identifier. However, it can still be used to search for an interface.
    </para>
    <para>
      All interfaces configured with libvirt should be considered as
      persistent, since libvirt is actually changing the host's own
      persistent configuration data (usually contained in files somewhere
      under /etc), and not the interface itself. However, there are API
      functions to start and stop interfaces, and those actions cause the
      new configuration to be applied to the interface immediately.
    </para>
    <para>
      When a new interface is defined (with virInterfaceDefineXML), or the
      configuration of an existing interface is changed (again, with
      virInterfaceDefineXML), this configuration will be stored on the host,
      but the live configuration of the interface itself will not be changed
      until either the interface is started (with virInterfaceCreate), or
      the host is rebooted.
    </para>
  </section>

  <section id="Application_Development_Guide-Network_Interfaces-XML_Format">
    <title>XML Interface Description Format</title>
    <para>
      The current Relax NG definition of the XML that is produced/accepted
      by virInterfaceDefineXML/virInterfaceGetXMLDesc can be found in the
      file data/xml/interface.rng of the netcf package, available at
      http://git.fedorahosted.org/git/netcf.git?p=netcf.git;a=tree. Below
      are some examples of common interface configurations.
    </para>
    <example>
      <title>XML definition of an ethernet interface using DHCP</title>
      <programlisting>
<![CDATA[<interface type='ethernet' name='eth0'>
  <start mode='onboot'/>
  <mac address='aa:bb:cc:dd:ee:ff'/>
  <protocol family='ipv4'>
    <dhcp/>
  </protocol>
</interface>]]>
      </programlisting>
    </example>

    <example>
      <title>Example 7.2 XML definition of an ethernet interface with static IP</title>
      <programlisting>
<![CDATA[<interface type='ethernet' name='eth0'>
  <start mode='onboot'/>
  <mac address='aa:bb:cc:dd:ee:ff'/>
  <protocol family='ipv4'>
    <ip address="192.168.0.5" prefix="24"/>
    <route gateway="192.168.0.1"/>
  </protocol>
</interface>]]>
      </programlisting>
    </example>

    <example>
      <title>Example 7.3 XML definition of a bridge device with eth0 and eth1 attached</title>
      <programlisting>
<![CDATA[<interface type="bridge" name="br0">
  <start mode="onboot"/>
  <mtu size="1500"/>
  <protocol family="ipv4">
    <dhcp/>
  </protocol>
  <bridge stp="off" delay="0.01">
    <interface type="ethernet" name="eth0">
      <mac address="ab:bb:cc:dd:ee:ff"/>
    </interface>
    <interface type="ethernet" name="eth1"/>
  </bridge>
</interface>]]>
      </programlisting>
    </example>

    <example>
      <title>XML definition of a vlan interface associated with eth0</title>
      <programlisting>
<![CDATA[<interface type="vlan" name="eth0.42">
  <start mode="onboot"/>
  <protocol family="ipv4">
    <dhcp peerdns="no"/>
  </protocol>
  <vlan tag="42">
    <interface name="eth0"/>
  </vlan>
</interface>]]>
      </programlisting>
    </example>
  </section>

  <section id="Application_Development_Guide-Network_Interfaces-Information">
    <title>Retrieving Information About Interfaces</title>

    <section id="Application_Development_Guide-Network_Interfaces-Information-Listing">
      <title>Enumerating Interfaces</title>
      <para>
	Once you have a connection to a host (a virConnectPtr) you can learn
	the number of interfaces on the host with virConnectNumOfInterfaces
	and virConnectNumOfDefinedInterfaces, and a list of those interfaces'
	names with virConnectListInterfaces and
	virConnectListDefinedInterfaces ("defined" interfaces are those that
	have been defined, but are currently inactive).  Each of these
	functions takes a connection object as its first argument; the list
	functions also take an argument pointing to a char* array for the
	result, and another giving the maximum number of entries to put in
	that array. All 4 functions return the number of interfaces found, or
	-1 if an error is encountered.
      </para>

      <example>
	<title>Getting a list of active ("up") interfaces on a host</title>
	<para>
          NB, error handling omitted for clarity
	</para>
	<programlisting>
<![CDATA[int numIfaces, i;
char *ifaceNames;

numIfaces = virConnectNumOfInterfaces(conn);
ifaceNames = malloc(numIfaces * sizeof(char*));
numIfaces = virConnectListInterfaces(conn, names, ct);

printf("Active host interfaces:\n");
for (i = 0; i < numIfaces; i++) {
    printf(" %s\n", ifaceNames[i]);
    free(ifaceNames[i]);
}
free(ifaceNames);]]>
	</programlisting>
      </example>

      <example>
	<title>Getting a list of inactive ("down") interfaces on a host</title>
	<programlisting>
<![CDATA[int numIfaces, i;
char *ifaceNames;

numIfaces = virConnectNumOfDefinedInterfaces(conn);
ifaceNames = malloc(numIfaces * sizeof(char*));
numIfaces = virConnectListDefinedInterfaces(conn, names, ct);

printf("Inactive host interfaces:\n");
for (i = 0; i < numIfaces; i++) {
    printf(" %s\n", ifaceNames[i]);
    free(ifaceNames[i]);
}
free(ifaceNames);]]>
	</programlisting>
      </example>
    </section>

    <section id="Application_Development_Guide-Network_Interfaces-Information-AltListing">
      <title>Alternative method of enumerating interfaces</title>
      <para>
	It is also possible to get a list of interfaces from the virNodeDevice
	API. Calling virNodeListDevices with the "cap" argument (capabilities)
	set to "net". This will return a list of device names (each starting
	with "net_"), and those device names can, in turn, be sent through
	virNodeDeviceLookupByName, then virNodeDeviceGetXMLDesc to get an XML
	string containing the interfaces' names, mac addresses, and 802.11
	vs. 802.03 status (wired vs wireless). See section 4.6 for more
	information and examples of using virNodeDevice functions for this
	purpose.
      </para>
    </section>

    <section id="Application_Development_Guide-Network_Interfaces-Information-Fetching">
      <title>Obtaining a virInterfacePtr for an Interface</title>

      <para>
	Many operations require that you have a virInterfacePtr, but you may
	only have the name or MAC address of the interface. You can use
	virInterfaceLookupByName and virinterfaceLookupByMACString to get the
	virInterfacePtr in these cases.
      </para>

      <example>
	<title>Fetching the virInterfacePtr for a given interface name</title>
	<programlisting>
<![CDATA[virInterfacePtr iface;
const char *name = "eth0";

iface = virInterfaceLookupByName(name);

if (iface) {

    /* use the virInterfacePtr ... */

    virInterfaceFree(iface);
} else {
    printf("Interface '%s' not found.\n", name);
}]]>
	</programlisting>
      </example>

      <example>
	<title>Fetching the virInterfacePtr for a given interface MAC Address</title>
	<programlisting>
<![CDATA[virInterfacePtr iface;
const char *mac = "00:01:02:03:04:05";

iface = virInterfaceLookupByMACString(mac);

if (iface) {

    /* use the virInterfacePtr ... */

    virInterfaceFree(iface);
} else {
    printf("No interface found with MAC address '%s'.\n", mac);
}]]>
	</programlisting>
      </example>

      <para>
	Note that, as shown in the examples, after you are finished using the
	virinterfacePtr, you must call virInterfaceFree to free up its
	resources (even if you undefined or destroyed the interface in the
	meantime). Another important detail: doing a lookup for a MAC address
	that has multiple matches will result in a NULL return and a
	VIR_ERR_MULTIPLE_INTERFACES error being raised. This limitation will
	be addressed in the near future with a new API function.
      </para>
    </section>
    <section id="Application_Development_Guide-Network_Interfaces-Information-Detail">
      <title>Retrieving Detailed Interface Info</title>

      <para>
	You may also find yourself with a virInterfacePtr, and need the name
	or MAC address of the interface, or want to examine the full interface
	configuration. virInterfaceGetName, virInterfaceGetMACString, and
	virInterfaceGetXMLDesc will take care of those needs.
      </para>

      <example>
	<title>Fetching the name and mac address from an interface object</title>
	<programlisting>
<![CDATA[const char *name;
const char *mac;

name = virInterfaceGetName(iface);
mac = virInterfaceGetMACString(iface);

printf("Interface %s has MAC address %s", name, mac);]]>
	</programlisting>
      </example>

      <para>
	Note that the strings returned by virInterfaceGetName and
	virInterfaceGetMACString do not need to be freed by the application;
	their lifetime will be the same as the interface object.
      </para>
      <para>
	The string returned by virInterfaceGetXMLDesc, on the other hand, is
	created especially for the caller, and the caller must free it when
	finished. virInterfacegetXMLDesc also has a flags argument, intended
	for future expansion. For forward compatibility, you should always set
	it to 0. The returned string is UTF-8 encoded; the same string may
	later be given to virInterfaceDefineXML to recreate the interface
	configuration.
      </para>

      <example>
	<title>Fetching the XML configuration string from an interface object</title>
	<programlisting>
<![CDATA[const char *xml;

name = virInterfaceGetXMLDesc(iface, 0);
printf("Interface configuration:\n%s\n", xml);
free(xml);]]>
	</programlisting>
      </example>
    </section>
  </section>

  <section id="Application_Development_Guide-Network_Interfaces-Configs">
    <title>Managing interface configuration files</title>
    <para>
      In libvirt, "defining" an interface means creating or changing the
      configuration, and "undefining" means deleting that configuration from
      the system. Newcomers may sometimes confuse these two operations with
      Create/Delete (which actually are used to activate and deactivate an
      existing interface - see section 7.5).
    </para>

    <section id="Application_Development_Guide-Network_Interfaces-Configs-Define">
      <title>Defining an inteface configuration</title>
      <para>
	The virInterfaceDefineXML function is used both for adding new interface configurations
	and modifying existing configurations. It either adds a new interface
	(with all information, including the interface name, given in the xml
	data) or modifies the configuration of an existing interface. The
	newly defined interface will be inactive until separate action is
	taken to make the new configuration take effect (for example,
	rebooting the host, or calling virInterfaceCreate, described in
	section 7.5)
      </para>
      <para>
	If the interface is successfully added/modified in the host's
	configuration, virInterfaceDefineXML returns a virInterfacePtr, which
	can be used as a handle to perform further actions on the new interface,
	eg making it active with virInterfaceCreate.
      </para>
      <para>
	When you are finished using the returned virInterfacePtr, you must
	free it with virInterfaceFree (this doesn't remove the interface
	itself, just the internal object used by libvirt).
      </para>

      <example>
	<title>Defining a new interface</title>
	<programlisting>
<![CDATA[/* xml is a char* containing the description, per section 7.2 */
virInterfacePtr iface;

iface = virInterfaceDefineXML(xml, 0);
if (!iface) {
   fprintf(stderr, "Failed to define interface.\n");
   /* other error handling */
   goto cleanup;
}
if (virInterfaceCreate(iface) != 0) {
   fprintf(stderr, "Failed to create (activate) interface\n");
   /* other error handling */
   goto cleanup;
}
virinterfaceFree(iface);

cleanup:
   /* ... */
]]>
	</programlisting>
      </example>
    </section>

    <section id="Application_Development_Guide-Network_Interfaces-Configs-Undefine">
      <title>Undefining an inteface configuration</title>
      <para>
	virInterfaceUndefine completely and permanently removes the
	configuration for the given interface from tho host's configuration
	files. If you might want to recreate this configuration again in the
	future, you should call virInterfacegetXMLDesc and save the string
	prior to the undefine.
      </para>
      <para>
	virInterfaceUndefine does not free the virInterfacePtr itself, it only
	removes the configuration from the host. You must still free the
	virInterfacePtr with virInterfaceFree.
      </para>
      <example>
	<title>Undefining br0 interface after saving its XML data</title>
	<programlisting>
<![CDATA[virInterfacePtr iface;
char *xml = NULL;;

iface = virInterfaceLookupByName("br0");
if (!iface) {
    printf ("Interface br0 not found.\n");
} else {
    xml = virinterfaceGetXMLDesc(iface, 0);
    virInterfaceUndefine(iface);
    virinterfaceFree(iface);
}
/* you must also free the buffer at xml when you're finished with it */]]>
--------------
	</programlisting>
      </example>
    </section>
  </section>

  <section id="Application_Development_Guide-Network_Interfaces-Lifecycle">
    <title>Interface lifecycle management</title>
    <para>
      In libvirt parlance, "creating" an interface means making it active,
      or "bringing it up", and "deleting" an interface means making it
      inactive, or "bringing it down". On hosts using the netcf backend for
      interface configuration (eg Fedora, RHEL), this is the same as calling
      the system shell scripts "ifup" and "ifdown" for the interface.
    </para>

    <section id="Application_Development_Guide-Network_Interfaces-Lifecycle-Activate">
      <title>Activating an interface</title>

      <para>
	virInterfaceCreate makes the given inactive interface active
	("up"). On success, it returns 0. If there is any problem making the
	interface active, -1 is returned.
      </para>
    </section>

    <section id="Application_Development_Guide-Network_Interfaces-Lifecycle-Deactivate">
      <title>Activating an interface</title>

      <para>
	virInterfaceDestroy makes the given interface inactive ("down"). On
	success, it returns 0. If there is any problem making the interface
	acrive, -1 is returned.
      </para>

      <example>
	<title>Temporarily bring down eth2, then bring it back up</title>
	<programlisting>
<![CDATA[virInterfacePtr iface;

iface = virInterfaceLookupByName("eth2");
if (!iface) {
    printf("Interface eth2 not found.\n");
} else {
    if (virInterfaceDestroy(iface) != 0) {
        fprintf(stderr, "failed to destroy (deactivate) interface eth2.\n");
    } else
        /* do whatever you wanted to do with interface down */
        if (virInterfaceCreate(iface) != 0) {
        fprintf(stderr, "failed to create (activate) interface eth2.\n");
        }
    }
    free(iface);
}]]>
	</programlisting>
      </example>
    </section>
  </section>
  <section id="Application_Development_Guide-Network_Interfaces-MemManager">
    <title>Interface object memory management</title>
    <para>
      Any time an application calls a function that returns a
      virInterfacePtr, it is implied that a reference counter has been
      incremented for that particular interface object. To decrement the
      reference counter (eventually resulting in the interface object's
      resources being freed), call virInterfaceFree. This reference counting
      assures that the interface object will not be freed while an
      application is still using it.
    </para>
    <para>
      For cases where an application makes a copy of a virinterfacePtr and
      stores it away somewhere which may require a lifetime longer than that
      of the original virinterfacePtr, virinterfaceRef should be called to
      manually increment the reference count (and virinterfaceFree should
      be called an extra time, when that copy of the virInterfacePtr is no
      longer being used).
    </para>

    <example>
      <title>Reference counting an interface object</title>
      <programlisting>
<![CDATA[virInterfacePtr iface;

iface = virInterfaceLookupByName("eth0");

mydata.iface = iface;
virInterfaceRef(mydata.iface);
/* now we're done with iface */
virInterfaceFree(iface);

...

/* now we're done with mydata.iface */
virInterfaceFree(mydata.iface);]]>
      </programlisting>
    </example>
  </section>

</chapter>

